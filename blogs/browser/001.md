---
title: 001 面试题
date: 2019-12-1
categories:
  - 浏览器
tags:
  - 面试
  - 浏览器
sidebar: "auto"
---

## 1. 浏览器的 eventLoop

> js 是单线程的，浏览器是多线程的， eventLoop 是由浏览器环境 webAPI 提供的，和 JS 引擎（v8）没有关系，
> eventlLoop 是一个事件循环机制。浏览器中的各种 web api 为异步的代码提供了一个单独的运行空间，当异步的代码运行完毕以后，会将代码中的回调送入到 Task Queue（任务队列）中去，等到调用栈空时，再将队列中的回调函数压入调用栈中执行，先执行完所有的微任务，再执行一个宏任务，然后再检测是否有微任务需要执行，等到栈空及任务队列也空了的时候，调用栈任会不断检车任务队列中是否有代码需要执行 ，这一个过程就是完整的 eventLoop.

## 2. 微任务和宏任务

> 宏任务：setTimeOut, setInterval(发音：set inter vo), UI rendering
> 微任务：Promise、requestAnimationFrame
> 当宏任务和微任务都处于 task queue，微任务的优先级要大于宏任务，即先将微任务执行完，在执行宏任务
> 队列也分宏队列和微队列，当主调用栈为空的时候，两个队列的执行情况如下：

1. 检测微队列是否为空，不为空取处一个微任务执行，任会执行步骤一，为空则执行步骤二；
2. 检测宏队列是否为空，不为空取出一个宏任务执行，然后执行步骤一，为空直接执行步骤一
   tips：再新建一个微任务会直接放到当前微任务队列中，继续执行

## 3. 如何创建一个微任务

> 可以通过 queueMicrotask（发音：ki ma cro task） 函数，或者 Promise.resolve(),
> 但是最好使用最底层的 queueMicrotask，

- 因为我们应当使用底层的 api 来实现，而非顶层的 api 进行模拟
- 模拟过程中，对于异常情况，会造成困恼，比如 `Promies.resolve`会将异常转化为一个`rejected`的`Promise`
- 模拟过程中，会创建额外的对象（造成一定意义上的浪费），比如`Promise.resolve`会返回一个`Promise`实例对象，而直接`queueMicrotask`则不会
- 除了微任务，其他类型的异步任务都有对应的`api`可供使用，比如宏任务、`RAF`
- 继上一点的基础上，语义性会更好，同时帮助开展理解这些不同异步任务之间的区别
  - `setTimeout(callback, 0)` - 宏任务
  - `requestAnimationFrame(callback)` - RAF
  - `queueMicrotask(callback)` - 微任务

## 4. chrome v8 的 gc 机制（自动垃圾回收机制）

### 垃圾回收机制策略

#### 标记清除算法

> 在 JavaScript 中，根对象是全局对象；
> 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

##### 两个阶段

1. 标记阶段： 垃圾回收器从根对象开始遍历，能访问到的对象都添加一个标记

2. 清除阶段：垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被表示为可到达对象，那么就将此对象占用的内存回收，并且将原来标签为可到达对象的表示清除，以便进行下一次垃圾回收操作

##### 何时开始垃圾回收？

通常来说，在使用标记清除算法时，未引用对象并不会被立即回收。取而代之的做法是，垃圾对象将一直累计到内存耗尽为止。**当内存耗尽时，程序将被挂起，垃圾回收开始执行**

##### 标记清除算法缺陷

- 那些无法从根对象查询到的对象都将被清除
- 垃圾收集后有可能会造成**大量的内存碎片**

#### 引用计数算法：无法处理循环引用

> 这是最初级的垃圾收集算法，已经没有浏览器用了
> 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。

### Chrome V8 垃圾回收算法

v8 使用的垃圾回收策略： 分代式垃圾回收机制，以对象存活时间分代。新生代（32MB）,老生代（1.4GB）
目的是通过区分【临时】与【持久】对象；多回收【临时对象区】（新生代），少回收【持久对象区】（老生代），减少每次需遍历的对象，从而减少每次 GC 的耗时

- 新生代算法：
  - Scavenge：一半使用（From 空间）一半闲置（To 空间），垃圾回收时，从 From 空间复制存活对象到 To 空间，完成复制，空间对换。牺牲空间换时间
- 老生代算法：
  - Mark-Sweep：标记清除，会有内存碎片。无需移动对象，存在内存碎片
  - Mark-Compact: 标记整理，为了解决内存碎片问题。整理时将活着的对象往一端移动，清理掉边界外的内存。需要移动对象，无内存碎片。
    优化： 增量式标记回收，拆分成很多小部分，与应用逻辑交替执行，有点像 React 的 fiber

### 参考文章

[v8 垃圾回收机制](https://juejin.cn/post/6844903781079973902)

## 5. 前端安全问题

## 6. 网页中的图片资源为什么放在不同的域名下

> 浏览器对请求的并发数目限制是针对域名的，包括一级域名下面的二级域名，所以使用不同的一级域名可以提升并行数目上限，提升资源的获取速度

## 7.浏览器与服务器建立一个 tcp 连接后，算法会在完成一个 http 请求后断开，在什么条件下会断开

> http 1.0 一个请求在收到服务器响应后就会断开连接，如果要维持连接，则要配置 connection: keep-alive
> 而 http 1.1 把这一个行为变成了默认行为，1.1 后除非设置 connection:close, 才会在请求完成后断开 tcp 连接

## 8.一个 tcp 连接可以同时发送多少个 http 请求吗？

> htpp 1.1 一个 tcp 一个 http 请求，http 2，多路复用，一个 tcp 连接可以同时发送多个 http 请求

## 9.浏览器 http 请求的并发性如何体现？并发请求的数量限制？

> 浏览器会同时和服务器建立多个 tcp 连接，同时发起多个 http 请求，chrome 同时最多 6 个 tcp 请求，不同浏览器稍有差异

## 10.浏览器的同源策略

> 同一协议，同一域名，同一端口

## 11. Performance(发音：pe for mance)

`performance` 接口可以获取到当前页面中与性能相关的信息

- 衡量首屏时间：window.performance.timing

## 12.setTimout、setInterval、requestAnimationFrame、requestIdleCallback

1. setTimout: 隔一段时间执行回调，多个在队列里时，必须等上一个回调完成才会执行下一个
2. setInterval：每隔一段时间执行回调，上次回调还没执行完也会进入下一次回调
3. requestAnimationFrame：保证回调函数在每一帧里面只渲染一次，一般用于高性能的动画渲染
4. requestIdleCallback: 在浏览器空闲时间执行（每一帧渲染时间不超过 16.6ms）一般用于执行重计算非紧急的任务

## 13.简单介绍一下 requestIdleCallback 及使用场景

requestIdleCallback 维护一个函数队列，回调函数将在浏览器空闲时间内执行
使用注意事项：

- 执行重计算而非紧急任务
- 空闲回调执行时间应小于 50ms
- 空闲回调中不要操作 dom，因为它本来就是利用的重排重绘后的空余时间，而操作 dom 又将造成重排重绘

## 14. url 渲染到页面的过程
